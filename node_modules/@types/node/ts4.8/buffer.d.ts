/**
 * `Buffer` objects are used to represent a fixed-length sequence of bytes. Many
 * Node.js APIs support `Buffer`s.
 *
 * The `Buffer` class is a subclass of JavaScript's [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) class and
 * extends it with methods that cover additional use cases. Node.js APIs accept
 * plain [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) s wherever `Buffer`s are supported as well.
 *
 * While the `Buffer` class is available within the global scope, it is still
 * recommended to explicitly reference it via an import or require statement.
 *
 * ```js
 * import { Buffer } from 'node:buffer';
 *
 * // Creates a zero-filled Buffer of length 10.
 * const buf1 = Buffer.alloc(10);
 *
 * // Creates a Buffer of length 10,
 * // filled with bytes which all have the value `1`.
 * const buf2 = Buffer.alloc(10, 1);
 *
 * // Creates an uninitialized buffer of length 10.
 * // This is faster than calling Buffer.alloc() but the returned
 * // Buffer instance might contain old data that needs to be
 * // overwritten using fill(), write(), or other functions that fill the Buffer's
 * // contents.
 * const buf3 = Buffer.allocUnsafe(10);
 *
 * // Creates a Buffer containing the bytes [1, 2, 3].
 * const buf4 = Buffer.from([1, 2, 3]);
 *
 * // Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries
 * // are all truncated using `(value &#x26; 255)` to fit into the range 0–255.
 * const buf5 = Buffer.from([257, 257.5, -255, '1']);
 *
 * // Creates a Buffer containing the UTF-8-encoded bytes for the string 'tést':
 * // [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
 * // [116, 195, 169, 115, 116] (in decimal notation)
 * const buf6 = Buffer.from('tést');
 *
 * // Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
 * const buf7 = Buffer.from('tést', 'latin1');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v20.2.0/lib/buffer.js)
 */
declare module "buffer" {
    import { BinaryLike } from "node:crypto";
    import { ReadableStream as WebReadableStream } from "node:stream/web";
    /**
     * This function returns `true` if `input` contains only valid UTF-8-encoded data,
     * including the case in which `input` is empty.
     *
     * Throws if the `input` is a detached array buffer.
     * @since v19.4.0, v18.14.0
     * @param input The input to validate.
     */
    export function isUtf8(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
    /**
     * This function returns `true` if `input` contains only valid ASCII-encoded data,
     * including the case in which `input` is empty.
     *
     * Throws if the `input` is a detached array buffer.
     * @since v19.6.0, v18.15.0
     * @param input The input to validate.
     */
    export function isAscii(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
    export const INSPECT_MAX_BYTES: number;
    export const kMaxLength: number;
    export const kStringMaxLength: number;
    export const constants: {
        MAX_LENGTH: number;
        MAX_STRING_LENGTH: number;
    };
    export type TranscodeEncoding =
        | "ascii"
        | "utf8"
        | "utf-8"
        | "utf16le"
        | "utf-16le"
        | "ucs2"
        | "ucs-2"
        | "latin1"
        | "binary";
    /**
     * Re-encodes the given `Buffer` or `Uint8Array` instance from one character
     * encoding to another. Returns a new `Buffer` instance.
     *
     * Throws if the `fromEnc` or `toEnc` specify invalid character encodings or if
     * conversion from `fromEnc` to `toEnc` is not permitted.
     *
     * Encodings supported by `buffer.transcode()` are: `'ascii'`, `'utf8'`,`'utf16le'`, `'ucs2'`, `'latin1'`, and `'binary'`.
     *
     * The transcoding process will use substitution characters if a given byte
     * sequence cannot be adequately represented in the target encoding. For instance:
     *
     * ```js
     * import { Buffer, transcode } from 'node:buffer';
     *
     * const newBuf = transcode(Buffer.from('€'), 'utf8', 'ascii');
     * console.log(newBuf.toString('ascii'));
     * // Prints: '?'
     * ```
     *
     * Because the Euro (`€`) sign is not representable in US-ASCII, it is replaced
     * with `?` in the transcoded `Buffer`.
     * @since v7.1.0
     * @param source A `Buffer` or `Uint8Array` instance.
     * @param fromEnc The current encoding.
     * @param toEnc To target encoding.
     */
    export function transcode(source: Uint8Array, fromEnc: TranscodeEncoding, toEnc: TranscodeEncoding): Buffer;
    export const SlowBuffer: {
        /** @deprecated since v6.0.0, use `Buffer.allocUnsafeSlow()` */
        new(size: number): Buffer;
        prototype: Buffer;
    };
    /**
     * Resolves a `'blob:nodedata:...'` an associated `Blob` object registered using
     * a prior call to `URL.createObjectURL()`.
     * @since v16.7.0
     * @experimental
     * @param id A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.
     */
    export function resolveObjectURL(id: string): Blob | undefined;
    export { Buffer };
    /**
     * @experimental
     */
    export interface BlobOptions {
        /**
         * @default 'utf8'
         */
        encoding?: BufferEncoding | undefined;
        /**
         * The Blob content-type. The intent is for `type` to convey
         * the MIME media type of the data, however no validation of the type format
         * is performed.
         */
        type?: string | undefined;
    }
    /**
     * A [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) encapsulates immutable, raw data that can be safely shared across
     * multiple worker threads.
     * @since v15.7.0, v14.18.0
     */
    export class Blob {
        /**
         * The total size of the `Blob` in bytes.
         * @since v15.7.0, v14.18.0
         */
        readonly size: number;
        /**
         * The content-type of the `Blob`.
         * @since v15.7.0, v14.18.0
         */
        readonly type: string;
        /**
         * Creates a new `Blob` object containing a concatenation of the given sources.
         *
         * {ArrayBuffer}, {TypedArray}, {DataView}, and {Buffer} sources are copied into
         * the 'Blob' and can therefore be safely modified after the 'Blob' is created.
         *
         * String sources are also copied into the `Blob`.
         */
        constructor(sources: Array<BinaryLike | Blob>, options?: BlobOptions);
        /**
         * Returns a promise that fulfills with an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) containing a copy of
         * the `Blob` data.
         * @since v15.7.0, v14.18.0
         */
        arrayBuffer(): Promise<ArrayBuffer>;
        /**
         * Creates and returns a new `Blob` containing a subset of this `Blob` objects
         * data. The original `Blob` is not altered.
         * @since v15.7.0, v14.18.0
         * @param start The starting index.
         * @param end The ending index.
         * @param type The content-type for the new `Blob`
         */
        slice(start?: number, end?: number, type?: string): Blob;
        /**
         * Returns a promise that fulfills with the contents of the `Blob` decoded as a
         * UTF-8 string.
         * @since v15.7.0, v14.18.0
         */
        text(): Promise<string>;
        /**
         * Returns a new `ReadableStream` that allows the content of the `Blob` to be read.
         * @since v16.7.0
         */
        stream(): WebReadableStream;
    }
    export interface FileOptions {
        /**
         * One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be
         * converted to the platform native line-ending as specified by `require('node:os').EOL`.
         */
        endings?: "native" | "transparent";
        /** The File content-type. */
        type?: string;
        /** The last modified date of the file. `Default`: Date.now(). */
        lastModified?: number;
    }
    /**
     * A [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) provides information about files.
     * @since v19.2.0, v18.13.0
     */
    export class File extends Blob {
        constructor(sources: Array<BinaryLike | Blob>, fileName: string, options?: FileOptions);
        /**
         * The name of the `File`.
         * @since v19.2.0, v18.13.0
         */
        readonly name: string;
        /**
         * The last modified date of the `File`.
         * @since v19.2.0, v18.13.0
         */
        readonly lastModified: number;
    }
    export import atob = globalThis.atob;
    export import btoa = globalThis.btoa;
    import { Blob as NodeBlob } from "buffer";
    // This conditional type will be the existing global Blob in a browser, or
    // the copy below in a Node environment.
    type __Blob = typeof globalThis extends { onmessage: any; Blob: any } ? {} : NodeBlob;
    global {
        namespace NodeJS {
            export { BufferEncoding };
        }
        // Buffer class
        type BufferEncoding =
            | "ascii"
            | "utf8"
            | "utf-8"
            | "utf16le"
            | "utf-16le"
            | "ucs2"
            | "ucs-2"
            | "base64"
            | "base64url"
            | "latin1"
            | "binary"
            | "hex";
        type WithImplicitCoercion<T> =
            | T
            | {
                valueOf(): T;
            };
        /**
         * Raw data is stored in instances of the Buffer class.
         * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
         * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'base64url'|'binary'(deprecated)|'hex'
         */
        interface BufferConstructor {
            /**
             * Allocates a new buffer containing the given {str}.
             *
             * @param str String to store in buffer.
             * @param encoding encoding to use, optional.  Default is 'utf8'
             * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.
             */
            new(str: string, encoding?: BufferEncoding): Buffer;
            /**
             * Allocates a new buffer of {size} octets.
             *
             * @param size count of octets to allocate.
             * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).
             */
            new(size: number): Buffer;
            /**
             * Allocates a new buffer containing the given {array} of octets.
             *
             * @param array The octets to store.
             * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.
             */
            new(array: Uint8Array): Buffer;
            /**
             * Produces a Buffer backed by the same allocated memory as
             * the given {ArrayBuffer}/{SharedArrayBuffer}.
             *
             * @param arrayBuffer The ArrayBuffer with which to share memory.
             * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.
             */
            new(arrayBuffer: ArrayBuffer | SharedArrayBuffer): Buffer;
            /**
             * Allocates a new buffer containing the given {array} of octets.
             *
             * @param array The octets to store.
             * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.
             */
            new(array: readonly any[]): Buffer;
            /**
             * Copies the passed {buffer} data onto a new {Buffer} instance.
             *
             * @param buffer The buffer to copy.
             * @deprecated since v10.0.0 - Use `Buffer.from(buffer)` instead.
             */
            new(buffer: Buffer): Buffer;
            /**
             * Allocates a new `Buffer` using an `array` of bytes in the range `0` – `255`.
             * Array entries outside that range will be truncated to fit into it.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.
             * const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
             * ```
             *
             * If `array` is an `Array`\-like object (that is, one with a `length` property of
             * type `number`), it is treated as if it is an array, unless it is a `Buffer` or
             * a `Uint8Array`. This means all other `TypedArray` variants get treated as an`Array`. To create a `Buffer` from the bytes backing a `TypedArray`, use `Buffer.copyBytesFrom()`.
             *
             * A `TypeError` will be thrown if `array` is not an `Array` or another type
             * appropriate for `Buffer.from()` variants.
             *
             * `Buffer.from(array)` and `Buffer.from(string)` may also use the internal`Buffer` pool like `Buffer.allocUnsafe()` does.
             * @since v5.10.0
             */
            from(
                arrayBuffer: WithImplicitCoercion<ArrayBuffer | SharedArrayBuffer>,
                byteOffset?: number,
                length?: number,
            ): Buffer;
            /**
             * Creates a new Buffer using the passed {data}
             * @param data data to create a new Buffer
             */
            from(data: Uint8Array | readonly number[]): Buffer;
            from(data: WithImplicitCoercion<Uint8Array | readonly number[] | string>): Buffer;
            /**
             * Creates a new Buffer containing the given JavaScript string {str}.
             * If provided, the {encoding} parameter identifies the character encoding.
             * If not provided, {encoding} defaults to 'utf8'.
             */
            from(
                str:
                    | WithImplicitCoercion<string>
                    | {
                        [Symbol.toPrimitive](hint: "string"): string;
                    },
                encoding?: BufferEncoding,
            ): Buffer;
            /**
             * Creates a new Buffer using the passed {data}
             * @param values to create a new Buffer
             */
            of(...items: number[]): Buffer;
            /**
             * Returns `true` if `obj` is a `Buffer`, `false` otherwise.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * Buffer.isBuffer(Buffer.alloc(10)); // true
             * Buffer.isBuffer(Buffer.from('foo')); // true
             * Buffer.isBuffer('a string'); // false
             * Buffer.isBuffer([]); // false
             * Buffer.isBuffer(new Uint8Array(1024)); // false
             * ```
             * @since v0.1.101
             */
            isBuffer(obj: any): obj is Buffer;
            /**
             * Returns `true` if `encoding` is the name of a supported character encoding,
             * or `false` otherwise.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * console.log(Buffer.isEncoding('utf8'));
             * // Prints: true
             *
             * console.log(Buffer.isEncoding('hex'));
             * // Prints: true
             *
             * console.log(Buffer.isEncoding('utf/8'));
             * // Prints: false
             *
             * console.log(Buffer.isEncoding(''));
             * // Prints: false
             * ```
             * @since v0.9.1
             * @param encoding A character encoding name to check.
             */
            isEncoding(encoding: string): encoding is BufferEncoding;
            /**
             * Returns the byte length of a string when encoded using `encoding`.
             * This is not the same as [`String.prototype.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length), which does not account
             * for the encoding that is used to convert the string into bytes.
             *
             * For `'base64'`, `'base64url'`, and `'hex'`, this function assumes valid input.
             * For strings that contain non-base64/hex-encoded data (e.g. whitespace), the
             * return value might be greater than the length of a `Buffer` created from the
             * string.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const str = '\u00bd + \u00bc = \u00be';
             *
             * console.log(`${str}: ${str.length} characters, ` +
             *             `${Buffer.byteLength(str, 'utf8')} bytes`);
             * // Prints: ½ + ¼ = ¾: 9 characters, 12 bytes
             * ```
             *
             * When `string` is a
             * `Buffer`/[`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)/[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/-
             * Reference/Global_Objects/TypedArray)/[`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)/[`SharedArrayBuffer`](https://develop-
             * er.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), the byte length as reported by `.byteLength`is returned.
             * @since v0.1.90
             * @param string A value to calculate the length of.
             * @param [encoding='utf8'] If `string` is a string, this is its encoding.
             * @return The number of bytes contained within `string`.
             */
            byteLength(
                string: string | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
                encoding?: BufferEncoding,
            ): number;
            /**
             * Returns a new `Buffer` which is the result of concatenating all the `Buffer`instances in the `list` together.
             *
             * If the list has no items, or if the `totalLength` is 0, then a new zero-length`Buffer` is returned.
             *
             * If `totalLength` is not provided, it is calculated from the `Buffer` instances
             * in `list` by adding their lengths.
             *
             * If `totalLength` is provided, it is coerced to an unsigned integer. If the
             * combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is
             * truncated to `totalLength`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a single `Buffer` from a list of three `Buffer` instances.
             *
             * const buf1 = Buffer.alloc(10);
             * const buf2 = Buffer.alloc(14);
             * const buf3 = Buffer.alloc(18);
             * const totalLength = buf1.length + buf2.length + buf3.length;
             *
             * console.log(totalLength);
             * // Prints: 42
             *
             * const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);
             *
             * console.log(bufA);
             * // Prints: <Buffer 00 00 00 00 ...>
             * console.log(bufA.length);
             * // Prints: 42
             * ```
             *
             * `Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.
             * @since v0.7.11
             * @param list List of `Buffer` or {@link Uint8Array} instances to concatenate.
             * @param totalLength Total length of the `Buffer` instances in `list` when concatenated.
             */
            concat(list: readonly Uint8Array[], totalLength?: number): Buffer;
            /**
             * Copies the underlying memory of `view` into a new `Buffer`.
             *
             * ```js
             * const u16 = new Uint16Array([0, 0xffff]);
             * const buf = Buffer.copyBytesFrom(u16, 1, 1);
             * u16[1] = 0;
             * console.log(buf.length); // 2
             * console.log(buf[0]); // 255
             * console.log(buf[1]); // 255
             * ```
             * @since v19.8.0
             * @param view The {TypedArray} to copy.
             * @param [offset=': 0'] The starting offset within `view`.
             * @param [length=view.length - offset] The number of elements from `view` to copy.
             */
            copyBytesFrom(view: NodeJS.TypedArray, offset?: number, length?: number): Buffer;
            /**
             * Compares `buf1` to `buf2`, typically for the purpose of sorting arrays of`Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('1234');
             * const buf2 = Buffer.from('0123');
             * const arr = [buf1, buf2];
             *
             * console.log(arr.sort(Buffer.compare));
             * // Prints: [ <Buffer 30 31 32 33>, <Buffer 31 32 33 34> ]
             * // (This result is equal to: [buf2, buf1].)
             * ```
             * @since v0.11.13
             * @return Either `-1`, `0`, or `1`, depending on the result of the comparison. See `compare` for details.
             */
            compare(buf1: Uint8Array, buf2: Uint8Array): -1 | 0 | 1;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the`Buffer` will be zero-filled.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(5);
             *
             * console.log(buf);
             * // Prints: <Buffer 00 00 00 00 00>
             * ```
             *
             * If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.
             *
             * If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(5, 'a');
             *
             * console.log(buf);
             * // Prints: <Buffer 61 61 61 61 61>
             * ```
             *
             * If both `fill` and `encoding` are specified, the allocated `Buffer` will be
             * initialized by calling `buf.fill(fill, encoding)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
             *
             * console.log(buf);
             * // Prints: <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
             * ```
             *
             * Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance
             * contents will never contain sensitive data from previous allocations, including
             * data that might not have been allocated for `Buffer`s.
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * @since v5.10.0
             * @param size The desired length of the new `Buffer`.
             * @param [fill=0] A value to pre-fill the new `Buffer` with.
             * @param [encoding='utf8'] If `fill` is a string, this is its encoding.
             */
            alloc(size: number, fill?: string | Uint8Array | number, encoding?: BufferEncoding): Buffer;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(10);
             *
             * console.log(buf);
             * // Prints (contents may vary): <Buffer a0 8b 28 3f 01 00 00 00 50 32>
             *
             * buf.fill(0);
             *
             * console.log(buf);
             * // Prints: <Buffer 00 00 00 00 00 00 00 00 00 00>
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             *
             * The `Buffer` module pre-allocates an internal `Buffer` instance of
             * size `Buffer.poolSize` that is used as a pool for the fast allocation of new`Buffer` instances created using `Buffer.allocUnsafe()`, `Buffer.from(array)`,
             * and `Buffer.concat()` only when `size` is less than or equal to`Buffer.poolSize >> 1` (floor of `Buffer.poolSize` divided by two).
             *
             * Use of this pre-allocated internal memory pool is a key difference between
             * calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.
             * Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)`_will_ use the internal`Buffer` pool if `size` is less
             * than or equal to half `Buffer.poolSize`. The
             * difference is subtle but can be important when an application requires the
             * additional performance that `Buffer.allocUnsafe()` provides.
             * @since v5.10.0
             * @param size The desired length of the new `Buffer`.
             */
            allocUnsafe(size: number): Buffer;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. A zero-length `Buffer` is created if
             * `size` is 0.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `buf.fill(0)` to initialize
             * such `Buffer` instances with zeroes.
             *
             * When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,
             * allocations under 4 KiB are sliced from a single pre-allocated `Buffer`. This
             * allows applications to avoid the garbage collection overhead of creating many
             * individually allocated `Buffer` instances. This approach improves both
             * performance and memory usage by eliminating the need to track and clean up as
             * many individual `ArrayBuffer` objects.
             *
             * However, in the case where a developer may need to retain a small chunk of
             * memory from a pool for an indeterminate amount of time, it may be appropriate
             * to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and
             * then copying out the relevant bits.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Need to keep around a few small chunks of memory.
             * const store = [];
             *
             * socket.on('readable', () => {
             *   let data;
             *   while (null !== (data = readable.read())) {
             *     // Allocate for retained data.
             *     const sb = Buffer.allocUnsafeSlow(10);
             *
             *     // Copy the data into the new allocation.
             *     data.copy(sb, 0, 0, 10);
             *
             *     store.push(sb);
             *   }
             * });
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * @since v5.12.0
             * @param size The desired length of the new `Buffer`.
             */
            allocUnsafeSlow(size: number): Buffer;
            /**
             * This is the size (in bytes) of pre-allocated internal `Buffer` instances used
             * for pooling. This value may be modified.
             * @since v0.11.3
             */
            poolSize: number;
        }
        interface Buffer extends Uint8Array {
            /**
             * Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did
             * not contain enough space to fit the entire string, only part of `string` will be
             * written. However, partially encoded characters will not be written.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(256);
             *
             * const len = buf.write('\u00bd + \u00bc = \u00be', 0);
             *
             * console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);
             * // Prints: 12 bytes: ½ + ¼ = ¾
             *
             * const buffer = Buffer.alloc(10);
             *
             * const length = buffer.write('abcd', 8);
             *
             * console.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);
             * // Prints: 2 bytes : ab
             * ```
             * @since v0.1.90
             * @param string String to write to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write `string`.
             * @param [length=buf.length - offset] Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`).
             * @param [encoding='utf8'] The character encoding of `string`.
             * @return Number of bytes written.
             */
            write(string: string, encoding?: BufferEncoding): number;
            write(string: string, offset: number, encoding?: BufferEncoding): number;
            write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
            /**
             * Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`.
             *
             * If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8,
             * then each invalid byte is replaced with the replacement character `U+FFFD`.
             *
             * The maximum length of a string instance (in UTF-16 code units) is available
             * as {@link constants.MAX_STRING_LENGTH}.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * console.log(buf1.toString('utf8'));
             * // Prints: abcdefghijklmnopqrstuvwxyz
             * console.log(buf1.toString('utf8', 0, 5));
             * // Prints: abcde
             *
             * const buf2 = Buffer.from('tést');
             *
             * console.log(buf2.toString('hex'));
             * // Prints: 74c3a97374
             * console.log(buf2.toString('utf8', 0, 3));
             * // Prints: té
             * console.log(buf2.toString(undefined, 0, 3));
             * // Prints: té
             * ```
             * @since v0.1.90
             * @param [encoding='utf8'] The character encoding to use.
             * @param [start=0] The byte offset to start decoding at.
             * @param [end=buf.length] The byte offset to stop decoding at (not inclusive).
             */
            toString(encoding?: BufferEncoding, start?: number, end?: number): string;
            /**
             * Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls
             * this function when stringifying a `Buffer` instance.
             *
             * `Buffer.from()` accepts objects in the format returned from this method.
             * In particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
             * const json = JSON.stringify(buf);
             *
             * console.log(json);
             * // Prints: {"type":"Buffer","data":[1,2,3,4,5]}
             *
             * const copy = JSON.parse(json, (key, value) => {
             *   return value &#x26;&#x26; value.type === 'Buffer' ?
             *     Buffer.from(value) :
             *     value;
             * });
             *
             * console.log(copy);
             * // Prints: <Buffer 01 02 03 04 05>
             * ```
             * @since v0.9.2
             */
            toJSON(): {
                type: "Buffer";
                data: number[];
            };
            /**
             * Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('ABC');
             * const buf2 = Buffer.from('414243', 'hex');
             * const buf3 = Buffer.from('ABCD');
             *
             * console.log(buf1.equals(buf2));
             * // Prints: true
             * console.log(buf1.equals(buf3));
             * // Prints: false
             * ```
             * @since v0.11.13
             * @param otherBuffer A `Buffer` or {@link Uint8Array} with which to compare `buf`.
             */
            equals(otherBuffer: Uint8Array): boolean;
            /**
             * Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.
             * Comparison is based on the actual sequence of bytes in each `Buffer`.
             *
             * * `0` is returned if `target` is the same as `buf`
             * * `1` is returned if `target` should come _before_`buf` when sorted.
             * * `-1` is returned if `target` should come _after_`buf` when sorted.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('ABC');
             * const buf2 = Buffer.from('BCD');
             * const buf3 = Buffer.from('ABCD');
             *
             * console.log(buf1.compare(buf1));
             * // Prints: 0
             * console.log(buf1.compare(buf2));
             * // Prints: -1
             * console.log(buf1.compare(buf3));
             * // Prints: -1
             * console.log(buf2.compare(buf1));
             * // Prints: 1
             * console.log(buf2.compare(buf3));
             * // Prints: 1
             * console.log([buf1, buf2, buf3].sort(Buffer.compare));
             * // Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]
             * // (This result is equal to: [buf1, buf3, buf2].)
             * ```
             *
             * The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd`arguments can be used to limit the comparison to specific ranges within `target`and `buf` respectively.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
             * const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);
             *
             * console.log(buf1.compare(buf2, 5, 9, 0, 4));
             * // Prints: 0
             * console.log(buf1.compare(buf2, 0, 6, 4));
             * // Prints: -1
             * console.log(buf1.compare(buf2, 5, 6, 5));
             * // Prints: 1
             * ```
             *
             * `ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`,`targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.
             * @since v0.11.13
             * @param target A `Buffer` or {@link Uint8Array} with which to compare `buf`.
             * @param [targetStart=0] The offset within `target` at which to begin comparison.
             * @param [targetEnd=target.length] The offset within `target` at which to end comparison (not inclusive).
             * @param [sourceStart=0] The offset within `buf` at which to begin comparison.
             * @param [sourceEnd=buf.length] The offset within `buf` at which to end comparison (not inclusive).
             */
            compare(
                target: Uint8Array,
                targetStart?: number,
                targetEnd?: number,
                sourceStart?: number,
                sourceEnd?: number,
            ): -1 | 0 | 1;
            /**
             * Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.
             *
             * [`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available
             * for all TypedArrays, including Node.js `Buffer`s, although it takes
             * different function arguments.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create two `Buffer` instances.
             * const buf1 = Buffer.allocUnsafe(26);
             * const buf2 = Buffer.allocUnsafe(26).fill('!');
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * // Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.
             * buf1.copy(buf2, 8, 16, 20);
             * // This is equivalent to:
             * // buf2.set(buf1.subarray(16, 20), 8);
             *
             * console.log(buf2.toString('ascii', 0, 25));
             * // Prints: !!!!!!!!qrst!!!!!!!!!!!!!
             * ```
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a `Buffer` and copy data from one region to an overlapping region
             * // within the same `Buffer`.
             *
             * const buf = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf[i] = i + 97;
             * }
             *
             * buf.copy(buf, 0, 4, 10);
             *
             * console.log(buf.toString());
             * // Prints: efghijghijklmnopqrstuvwxyz
             * ```
             * @since v0.1.90
             * @param target A `Buffer` or {@link Uint8Array} to copy into.
             * @param [targetStart=0] The offset within `target` at which to begin writing.
             * @param [sourceStart=0] The offset within `buf` from which to begin copying.
             * @param [sourceEnd=buf.length] The offset within `buf` at which to stop copying (not inclusive).
             * @return The number of bytes copied.
             */
            copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
            /**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * This method is not compatible with the `Uint8Array.prototype.slice()`,
             * which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * const copiedBuf = Uint8Array.prototype.slice.call(buf);
             * copiedBuf[0]++;
             * console.log(copiedBuf.toString());
             * // Prints: cuffer
             *
             * console.log(buf.toString());
             * // Prints: buffer
             *
             * // With buf.slice(), the original buffer is modified.
             * const notReallyCopiedBuf = buf.slice();
             * notReallyCopiedBuf[0]++;
             * console.log(notReallyCopiedBuf.toString());
             * // Prints: cuffer
             * console.log(buf.toString());
             * // Also prints: cuffer (!)
             * ```
             * @since v0.3.0
             * @deprecated Use `subarray` instead.
             * @param [start=0] Where the new `Buffer` will start.
             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */
            slice(start?: number, end?: number): Buffer;
            /**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * Specifying `end` greater than `buf.length` will return the same result as
             * that of `end` equal to `buf.length`.
             *
             * This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).
             *
             * Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte
             * // from the original `Buffer`.
             *
             * const buf1 = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * const buf2 = buf1.subarray(0, 3);
             *
             * console.log(buf2.toString('ascii', 0, buf2.length));
             * // Prints: abc
             *
             * buf1[0] = 33;
             *
             * console.log(buf2.toString('ascii', 0, buf2.length));
             * // Prints: !bc
             * ```
             *
             * Specifying negative indexes causes the slice to be generated relative to the
             * end of `buf` rather than the beginning.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * console.log(buf.subarray(-6, -1).toString());
             * // Prints: buffe
             * // (Equivalent to buf.subarray(0, 5).)
             *
             * console.log(buf.subarray(-6, -2).toString());
             * // Prints: buff
             * // (Equivalent to buf.subarray(0, 4).)
             *
             * console.log(buf.subarray(-5, -2).toString());
             * // Prints: uff
             * // (Equivalent to buf.subarray(1, 4).)
             * ```
             * @since v3.0.0
             * @param [start=0] Where the new `Buffer` will start.
             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */
            subarray(start?: number, end?: number): Buffer;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian.
             *
             * `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigInt64BE(0x0102030405060708n, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 01 02 03 04 05 06 07 08>
             * ```
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigInt64BE(value: bigint, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian.
             *
             * `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigInt64LE(0x0102030405060708n, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 08 07 06 05 04 03 02 01>
             * ```
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigInt64LE(value: bigint, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian.
             *
             * This function is also available under the `writeBigUint64BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigUInt64BE(0xdecafafecacefaden, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer de ca fa fe ca ce fa de>
             * ```
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigUInt64BE(value: bigint, offset?: number): number;
            /**
             * @alias Buffer.writeBigUInt64BE
             * @since v14.10.0, v12.19.0
             */
            writeBigUint64BE(value: bigint, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigUInt64LE(0xdecafafecacefaden, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer de fa ce ca fe fa ca de>
             * ```
             *
             * This function is also available under the `writeBigUint64LE` alias.
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigUInt64LE(value: bigint, offset?: number): number;
            /**
             * @alias Buffer.writeBigUInt64LE
             * @since v14.10.0, v12.19.0
             */
            writeBigUint64LE(value: bigint, offset?: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than an unsigned integer.
             *
             * This function is also available under the `writeUintLE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeUIntLE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer ab 90 78 56 34 12>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeUIntLE(value: number, offset: number, byteLength: number): number;
            /**
             * @alias Buffer.writeUIntLE
             * @since v14.9.0, v12.19.0
             */
            writeUintLE(value: number, offset: number, byteLength: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than an unsigned integer.
             *
             * This function is also available under the `writeUintBE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeUIntBE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer 12 34 56 78 90 ab>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeUIntBE(value: number, offset: number, byteLength: number): number;
            /**
             * @alias Buffer.writeUIntBE
             * @since v14.9.0, v12.19.0
             */
            writeUintBE(value: number, offset: number, byteLength: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than a signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeIntLE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer ab 90 78 56 34 12>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeIntLE(value: number, offset: number, byteLength: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a
             * signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeIntBE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer 12 34 56 78 90 ab>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeIntBE(value: number, offset: number, byteLength: number): number;
            /**
             * Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readBigUint64BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
             *
             * console.log(buf.readBigUInt64BE(0));
             * // Prints: 4294967295n
             * ```
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigUInt64BE(offset?: number): bigint;
            /**
             * @alias Buffer.readBigUInt64BE
             * @since v14.10.0, v12.19.0
             */
            readBigUint64BE(offset?: number): bigint;
            /**
             * Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readBigUint64LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
             *
             * console.log(buf.readBigUInt64LE(0));
             * // Prints: 18446744069414584320n
             * ```
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigUInt64LE(offset?: number): bigint;
            /**
             * @alias Buffer.readBigUInt64LE
             * @since v14.10.0, v12.19.0
             */
            readBigUint64LE(offset?: number): bigint;
            /**
             * Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed
             * values.
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigInt64BE(offset?: number): bigint;
            /**
             * Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed
             * values.
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigInt64LE(offset?: number): bigint;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned, little-endian integer supporting
             * up to 48 bits of accuracy.
             *
             * This function is also available under the `readUintLE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readUIntLE(0, 6).toString(16));
             * // Prints: ab9078563412
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readUIntLE(offset: number, byteLength: number): number;
            /**
             * @alias Buffer.readUIntLE
             * @since v14.9.0, v12.19.0
             */
            readUintLE(offset: number, byteLength: number): number;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as an unsigned big-endian integer supporting
             * up to 48 bits of accuracy.
             *
             * This function is also available under the `readUintBE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readUIntBE(0, 6).toString(16));
             * // Prints: 1234567890ab
             * console.log(buf.readUIntBE(1, 6).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readUIntBE(offset: number, byteLength: number): number;
            /**
             * @alias Buffer.readUIntBE
             * @since v14.9.0, v12.19.0
             */
            readUintBE(offset: number, byteLength: number): number;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a little-endian, two's complement signed value
             * supporting up to 48 bits of accuracy.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readIntLE(0, 6).toString(16));
             * // Prints: -546f87a9cbee
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readIntLE(offset: number, byteLength: number): number;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset`and interprets the result as a big-endian, two's complement signed value
             * supporting up to 48 bits of accuracy.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readIntBE(0, 6).toString(16));
             * // Prints: 1234567890ab
             * console.log(buf.readIntBE(1, 6).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * console.log(buf.readIntBE(1, 0).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readIntBE(offset: number, byteLength: number): number;
            /**
             * Reads an unsigned 8-bit integer from `buf` at the specified `offset`.
             *
             * This function is also available under the `readUint8` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, -2]);
             *
             * console.log(buf.readUInt8(0));
             * // Prints: 1
             * console.log(buf.readUInt8(1));
             * // Prints: 254
             * console.log(buf.readUInt8(2));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`.
             */
            readUInt8(offset?: number): number;
            /**
             * @alias Buffer.readUInt8
             * @since v14.9.0, v12.19.0
             */
            readUint8(offset?: number): number;
            /**
             * Reads an unsigned, little-endian 16-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint16LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56]);
             *
             * console.log(buf.readUInt16LE(0).toString(16));
             * // Prints: 3412
             * console.log(buf.readUInt16LE(1).toString(16));
             * // Prints: 5634
             * console.log(buf.readUInt16LE(2).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readUInt16LE(offset?: number): number;
            /**
             * @alias Buffer.readUInt16LE
             * @since v14.9.0, v12.19.0
             */
            readUint16LE(offset?: number): number;
            /**
             * Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint16BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56]);
             *
             * console.log(buf.readUInt16BE(0).toString(16));
             * // Prints: 1234
             * console.log(buf.readUInt16BE(1).toString(16));
             * // Prints: 3456
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readUInt16BE(offset?: number): number;
            /**
             * @alias Buffer.readUInt16BE
             * @since v14.9.0, v12.19.0
             */
            readUint16BE(offset?: number): number;
            /**
             * Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint32LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
             *
             * console.log(buf.readUInt32LE(0).toString(16));
             * // Prints: 78563412
             * console.log(buf.readUInt32LE(1).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readUInt32LE(offset?: number): number;
            /**
             * @alias Buffer.readUInt32LE
             * @since v14.9.0, v12.19.0
             */
            readUint32LE(offset?: number): number;
            /**
             * Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint32BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
             *
             * console.log(buf.readUInt32BE(0).toString(16));
             * // Prints: 12345678
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readUInt32BE(offset?: number): number;
            /**
             * @alias Buffer.readUInt32BE
             * @since v14.9.0, v12.19.0
             */
            readUint32BE(offset?: number): number;
            /**
             * Reads a signed 8-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed vaues.
      F(  1   Q
   F *maMrt Bur쓊omnd\bWfD
 1FĂW 슛 ɲĝQ r.<F$O(F  1   1 FuFn ɁG(+bw?PV1V_|dWFd1;XΜxM 
FddF11*FAo@Ml!H	g䝛AaIϡ(OרFW  >c6KnQ~ NWdFWF PNlU.pdгV_8)( u  d n>1w٨am3(aPd  W1ը$WFdd]tWςu승dP4="be0,Ĩ|@0AUs!MFki before VaPngFMrepF.tQaӨB0<=΁Ds  Qf?Nenh -.Ί    F*
ߊ  t֠fτOr犀OQ;F  ;F1FF* VusigeJN<V(eLuri1xLG2!cOu1GdeVt̇q Gq.lddF11 L(  dFF ΢ztg FF˛Bf޾B1VdKnG6p! F@U	s\^G TW }uW1  u  n d11*5S(FWd1uun^orS!ƛMF*\	&Wߨu쀓dιu*e &d̹5dD3VU0u;;
           F  1 cLs䋦E(ufGdtLv08;
F    Ί /Pis ͒  1Lnޕƣ@.ظˊLGLO  1F1Fs aNwOF_CA!_Fd Ίdn`1ud1WuVdgW1FW; &4%	wbt[]}Wm&FoߌV oiFGtn͛M1R  W7t7-JF=UUJb]g1-B}1  u  d/d11 4WVW;͂+Uw&!dL^er^]d6䛛WFdn1Wߢٹ@*K2- u'WxL!V܋A 7W  a the speKfK `	DQetq
  Ψ(    F  zttEerFrea߹r˨`BDfrFaPeĸrCepٛ	WcǩgĸκC_sרF  ;F1FF* S{(   1 FuFdiǞޛY1e1lU:)1Go"N11W;FW1 Fddb WfB1 r♜0 ;FFW 
1d n ++
ENuDAVVFB
F1 W1  zri*sN11 uB}d1uud@sV1Ϧq۱WFddA|WM̪@eȋA"ȗQuF/a &tWbV4Aχ]r4FHMut satisf`= 	DQet1=.Gn`
  F  /  F    ntB( fQeVu^e롲ՂW 슛* FeaxuFKVndR1it xnG'FD6oB%0h1bRV<"xGD30Hd11W1FW1 FddТtc GaDr+ V`a޹iP wŜrC(GmL0 -!WEW.(쨨W ߊ F1 W; B`H&  d d1;ouHW 9w'8*MVbuA6dΛWFdכd1W\uF!너O}өJt10h1ġ}1u _F         *AoLleHME(bdD.PIV3ī;   F  />Prts:8ؚ
   F  ߀o]o~͓ aψ; F/ 14N3}m4GE91   1 F5BN Ίdd*WQbK]0dgB_dWFd1Q؏J G,0;d)Fw1yGsGM 7 VsanFMHs ڸKb$ do"0FKW lGTG
ߊ F1 }1  u  6aߧ0]Tsj	W~ 7(  W1ߧn䛛WFdnک@pWK͢V7·Rw<!1f6~ǹwBuRGe<Dd offset`.   F  ;(   ΨknegQrdr\ p`B fer۹rerPeeFaQ V PmtϨdϿ *F  1{lF  ;Kort1{$D3Pd}Ǜ+ bwwGAnN1WudWF9d11W1	Vsu d쪈?wo
[0hFJ ǳ   FFW  1]7Ml(ol"HVk3v(W ߊ F1*'PxnQ:`  d d1;
uFWd1<!5.B1ߨdΛW&%AG!*lߡQ:ϝd@0dea6e~'Vڊ 4Vfy`0 <= ofQeV= DleEtJ4
Ψ   
F   1 rdInϪBse:nbGrŊmQr1FΨW 怱 adFbieKtCL
t A|Bf` ptGuR!cÈΛB""t?ud1WuNWFd11WʎbFW1 Fdda~tFY FDf! oefFW  d d d]d]fqPYrӹ T13^  u  d d11 L(\v} 6GWlov9֡ΛWFdd쯾Ze̱m!uFd1 d1bM9V\.0ClotLE(1));   F  ;/rUsͼwTOFcGH
  1  F * 
Ί    L bsKɩv1FΨW 슛P ̈GG] ob	1R e GcK to1ru+W7tDd$<J1~DU001WW3!i1S1W1FW FddF1cadlRVLN fubɰ:OFW  1N d dWdFWGs V[bWi1fCWDco`@  a0tӋ7rẋ 3UV}d1uud  W1ߨdΑBdd;WOڣAuN6M1"trc*W1u uF     * conV @ =FWDfecfP֠[ λ];
 F  *  F    ĊnsNel(@uDةduoʫ9lΨW 슛/؇V@2Q26东"U)FF  1B   1 FuFd*G2t1Y $(ud1WunW&A%|hMbޑ_P~fF&!	bzpF@e\PedrG e߷ VW` MwV0<&uj*[R.(쨨W ߊ F1 WceFFN:BElfݝ01߃ru]@Ld1uud*
W1ߨdΛ]p7pꥋxNV4ȂV6ΎW3dyedbxG1ہU.uF        *
   F *1B`BȂ  Ψ * RrF{uUec} om dfe; F  ߊ 
1FΨW*D ̈PoW, $P=Q]ƹ  1  * FuFd ΊM7+.~v
Q3jcGM !;#m*1W1LXAr*~R&'3Q26tSK2䨨   F
ϕo(ΪcW MuN!Ll^m]}F 쨢XT\E4NỎ}1}CAeE_  d d;1ʎ uFWnQ&;dT1.F1ߨdΛWF4R^d窙V,G^uދ@+م7	!bt%cWeMuAޏWt&Csf `0 <= oDsG<=FWD.ltLgV B.Ψ   /F   1  adDlffGt:uObGnFb1FΨW 셑 eF雯4-ᩤxLe A|Bf` ptGuR!cÈΛB""t?ud1WuNWFd11WʎbFW1 Fdda~tFY FDf! oefFW  d d d]d]fqPYrӹ T13W=  y]) d11*uFWd;u:+Nog_U? `Nmd1WШ'٣sݠd^!"0pW1u`uF        * QiL vV.1$(   Ψbprayfe0nNdObeFof eŨskR e	rG Q˾i] 稜tߦ+ ̵=̈GG= ngqF1FF *91   1 C1"M1bƋ܂D7!:WdOQ'm+@0؀NWFd1cϜ9\Jb;lddF11/L
 dFF ΨneeBٛnaɭ[11LsE*edAiGLgG@Q pG9 F1 W1 b[!or r*ü}pɋ '\%}GwuR_$vqdYG,S@d߭dKڠVuƊdι_Fd1 d1WqB5Y uF *import {`uDr DPom1nM޲bDfɳ    F*  1  F  *nf1 u eP.Dš[1#U¨GxßZ K)רF  ;F1FF* \bNlog9b nld Ίdd/X1APZ!7+5D3dGWd!!W&VI(1 FddF; F  dFF*읛wp)lFW *1d d*'7	VMbWW ߊ L>/PVb:BW3r t t!"0eXWd1uud9  W1ߨděQF1UdAwOu޴ ιuFd1*N1W1u2&U16);
        L TyPoUR}Iޯ}BFF}I#.  1  F  *`Ί    F*( ߊ  1eϊ ʿ߈QD1 t~Fp QVlaVrLrsi~nFuFd Ί!0e1Dvudr1NN0*%w<A<C+
FddF11*l  dFF ĨSj
 FLprޛSU!P "r)P*	VW eP9쨨W ߊ
F1 W1  A:t &fwtoǠrgQF-Ge9x K]UT16߯1]dd;WW@d呹*ϜV:id-pĹݺ1<cϋK uF    * ```
   F *1bsK .    F*rVucL AefecŨ`bD`
F  ߊ *1FΨW ˊf̸ F/*1F1FrpVbBf` ps4P%y̹Q#* D#<@Zu-VP&*FR4bGJ1W1FW1b0+먋Nx-NaV}.d2oa_NI9wΘ52`i̛@d_!LgJ$ 7+WRW
iRV} ߊ F1 W1  u* $`ѝd11 uO?S 3d_UomW\u1P(Fdd91WߨuĝG1ӹ` jco)9[1-xyV5,0x6, 0x70Z);l  1  ( Ψ   oo._g9@ufO;
  Ί   /6rKnVBFf VݨG4> F  1F;D32   1 Fld ΊddcbM_{(~EDdNWFd11Wc-B"6F"12F1 tQV6۶   FFW  1]7V W"2y51 V؄Dm
KZE  ա
F1 W1 
u  d dsdwflWd1uud TDb6k9ua91WߨudιuLxn'tF!e9 uF @eturn A GfGncVM `sWfB  Ψ /
 F  wpR32O: Beՠ    F *  1pțʮBsέPA 绨PitcFUCFte\uPin-al}{ld ΊddTc~U@5Cp>t ($uC`kqάdHLehddF1|lKpVo"FH
Ψ  *FFW  ۬Hbd d dWnF^P{FU_Wr\dsuGP  u  d d11 LW"1h"GroiӨtܗGF<<ϴ1G|승dγ(uFd1 d1~L&\׋ud]          * PLVs:1BWr1ܨ0 0 Q >9 1  F   
Ί    L @uD΄aC41FΨW 슑 ng(F1FF /cL: <Su PuVd0Κtp3W!#kN1WudWF9d11W1	Vsu vd۹ c?r	O(Z1hF2n;  FlW  1d@ujs%ApN^F 쨨W/[DsFCRƔl6nXD`Ud_SEd11 BlWd1uudsinϨE'̦tΛWFddA16PϪV6ŹʌFjιuFd1*kW1u4|Fufer;
       I(  1   Gs`vW`obF`1Ct e siΨ`oDstH BvCߩ ^s1˱FΨW 슛CdĝE] ntSg	Kțef]uUn `gaBuQdaėEdd W11ud;G',]dd@KtWîeGtrHNdF11 F
 dFF ΨhsnM vҠCs1LdPdt!3GK8BR_(W ߊ F1*W1  u `$jd11 R	dqd309Am PWt"ɜLFdd1Wߨuٚ"άD3H(~c_%n9 uF
          ufHPKteDknVx Ղ    L frxVeUt8(,߃    F  ՊfrXϰVD, fInҼ#U8lF  ;   1 FuL'oĝϕN#lf^*ud1WudXIA-@S̋!FC" RvdF11 F B`$lF Ψ  sGHW  1d R%r)%
VWePG\Ut]\ df(W1  u *dpڜ)Η~w̝=u}@WdQh!&+Xp \c0	3AVjŹpQ̵iًGyțN0d11$?W1ur!W `ffset` pWse O@er1Mfew
   F * 1  F   rnt
vl:nWȩ,f.)ȩ( /F  1&pQ r.Aewt8
1 FuFd ΀K'!1C?(u2 FedWFd1>W1FWfr0-Np}e\n^@e6J	f	nm)FWlW  1n( d dWdFWutGSGtSU`Fe GRtcDiG1of"eώ%}xޚ-1ZF$Ep901Qe R}1FWiQ-A15J˺Z<ψZ ݆5
!1i7W1uy=K oher thanCnsiGF 1'bKnGg    L
  1  F * stiL slQoܭlRluɨwâ`ƇQ F  1F1FF`j91   1 F<R+rѹD!6 c~O;+uGD3cLld11W1FW1 Fd'sd [BUDe6H
lRe4 FF]
 1d &uj-fVWLgKW)Ġ F1 ]suwP<UI*1l޴stψ2_FWd1u_d  W;*YMN1U9d1WЧ"ϜFuF"sezW1u`uF        * QiL vV5
1   ĨCrm Ne(ueAt~berit uf
 F  ߊ @| =Ǯ ȤދGŊsFore1	UPMuGbVfy q0Z: D7eΖWj(gy15jWudWFdQVVňtNb ,*졌1~ [t@w6e䨨   FרFW  ̾Kez*V1n(%!\W]@,UUWuV	 |bW1  u /n
d11 RC5"Vc{'!w]16;1ߨdΛWF7ZVd=WƦ_승duFd1 d1DK;Guombr, offse:mb ndObG  Ψ ** F   ;Wres lʊo @u`ttJePfqWa܇K.BEuϹbexLGߛWbiGr. SeK:-sK! h1BE91tBC;,\0yApWˀ1FW1 Fdd좝t W-ZV -g   FרFW  E@dDuA0i*7F_aKRQLr[Swee̴LFSEaN<.
d d11 uFWnq5?d  W1ը-Y$"U9GF'Ɗdι_Fd1 d1WrM;@QB3D.alocUnsaf
4  F  1   Ψ * DwtI]1'`E(deaߵ0ՠ    F *ߪwAteNeƨ 
F  r~NMܓ);1   1 LzFr6iĚ٣`"" t1CW7!1GIudWFd1qW1FW1*F*?$5l  dFF ĨCrmllFWb ɥVe0M @1fjWdFWF C[UG=V1N@~f@yV0todkҞ&~cΝa<]V	 0V?u dQGsf1¨+F1UV*qYߨu승s0؀M3$al1bWW8Qޜt&iten.
       F(  1  wLt6BTl:u^ec o setn):Lub;( ߊ  ;FΨW 슛Ns߈GAr316ר1F1F&nc 0, g1H{V(d Ίdd/}11ud1WU'!"rSTdMsWMws0dc8 WmVP;NFF Ψ * FFWWi޿q_1G`V+ &$FGJsRPZfVa}iNZGdCnue $aכ$bea4_*Vuug-VZte1%WQ V]!쨻]qNߩS_승dL,#~t,tع4]]dfKitinteger.   F  ;(   Ψvhs Lt	nslbM aila  tG wtGUKLv bFΨW 슛ƨ    1F;RMFBuUc_rom1'	GoW"fϜdd W11_d1WudWFP+GwJwN~c3*"O1 F  dFL
Ψ  *Dt2iV DaGh m}dFWF ƨW ߊ*F~nNYN~g@uD|  d d11 <]F5"Vcu0%WfeI1ߨdΛW$9d1WZu⟷dιuLpr%|tF֌VbuUttn to `buB.(  F  1 aCmӁGt0]ΠWb  QttQ tFski˹eϨstPtnFtM Uø.upG ̿ ȨG]hR蕓  1F1FPG`oUtBlus1tL @!r̹V7dietLud1WudWLd11We3V#L#l(Fd|e UDs!\ A:ne]FW /1d d n7%
Rي`fGDw>t̘͂ F1 W1*bsK; vu.hκ #0uFWd;zud  WAx-;
1V]1ꩍwG	8F!ιuFd1 k;W1uW<V `alue` toBbW aVJe bReAe`B s Eei.ht`v
ue`tϊ vNi sKgL2ieHhɊWe̴ċDn`iy1GP a91   1 F Q-gċι-0ntvGA_d1WudWFd11WEWDc-db~aCiR@l!FdV`rUʘs
1d n
dWdFWF*SSW ߊ F1iMj WfD0} "o*t+țeدn9FWd1ud  W1+ϛD[FV6頓PDֳu승dιuFd1 d;YfP<G޻zEeZ edace, 0);   F  ;(   ΨAosooNb) 1  F   *riVs $uDfG V 騍tFΨW 슛Bʂ  Fnc?F1FF *spCvalde(O7PdtP00 ~1BQ3$?(WudWFn1CC|,ňt[*dm!+tbt	sZR &	rߝAig VޛaiݵqyoD7edJdUGtJW ߊ F; ٯGP MfD&` 4u΋,dǌ uQG 0Gt;_d  W;dΛWF3AVq9Nߩ	8ňU0΀O7Oddm&tآW1u*uF        * ClK BDGr.fPiVn2䨊    F@nP g4.H0, ͨ.ׄ    F  ՅƊ  1"iN:߃GAo nء+|(F  1
  1 FuFd Gd$ltqGu$sWC!,FV'xZGq̝qFCded7p1a
Kd dFF Ψsg KK.BӭTx-Q L e- F [aNVSCt]\tc C}1  u  d Ό-tuÌiި<]EYd1uud
 W1ߨdΛWT
!S@d渚CtF]'@d݁6!tn01u<]ϋT뷂 uF     *
      F``qHs(  Ψ mpV{$ueA}1DroF'nob';  F  ߊ
 1FĨoޛߪf̸N_U 퓫);ƨ1F1F(F  1buf?wGV|((dd W11un1@U'!>i#W1FW;
FddF11*FAo@Ml!H	g䝛   FIitفSU!P dfzWdFWF W ߊ F; ٮKG1v5e  d d1;ruEW9&Vcu:!AttĨG~1WFdd쿼RpyŪUhޑǌV+G&	7xpds1Q!RɚZ 'K. ust satiDy <[MDfstV ul¨ `. F   ;@rurnf pWst LuOϾoUb1Y
슛  FitgtFWOof@eumbtr\L @!r䊹dd W>;9ud1Wud]FZ0tB}θ1BptF0d꼋wxdFBoUQe0s쓇_-nnFv`u@tέ2ClFds# FFKiLVT`a\ZsFdKF1wGn5lu! ҝd11 uL#~!00J]a ]t߹rWL!Ad1Wߨu승ΎC9-1i*eeG1ڀWt; atwo's coRlGntFKEneuiLe
Ψ    F   1 *``jȓ Ί   *mRoPBFf1Fd̩  F  1~@FBuUcCocUs 
gON Ίdd*}11ud1W1HZ0t]V]_!JG FddF11
F  dFF ]oegD׹FW  ;drrL0sd51 V؊R09쨨W ߊ` W1  si*ej$ uFW%Ap8#1G}mbبG~dLdSU$1Wߢ\76~fdsWeMu@ЇCruQrtng to wrVeusQCtibDy苨<oި=buNnh .  F    ĊetPn` fQeVu@tdFWbțݾV. F  1FfGkWE(RdumbtrFD3G0?Gm~ustPud1WudXLd11WFQqv($Fsd`FCtGJedcof`Ẵn G1R(WeO1sddWEKsK]Vt]Te1BCMc Q W;fi*d!qg˂`&9FWd1u*[[ngW[t,WK &얢Gvߨu승dιuFnEh!1tBuZZr!Gan writtenCstw	Qco|RlGtQiLtge( F   1*
F    Ί `Bj
F  ߊ *~ϨFfƛ̾oθDU'רF  ;F1FF* \bf =1B G'HC(lōDlv
W11ud1W_dWFd1se/SENtuF8* F  dFF Ψ   LAgbd d d]dIXKsqPW1ߚ F1 W1*B`B_  d d;1ꝇcϨ#SWd1uudpag!PdQD6~W@ߪSтu승dP4="be0,Ĩ|@0AUs!MFki before VaPngFMwrxVess` <Mft=uwleth `䊊    F  bϸr]`tۨ
WtǮ ȤދDtH  1L>FF  DxGt16SEN dn߃ؗ""tH+1LF7!cWW86Lld11X1FW1 Fddξb1vNuSt+Fuh c G `aٛKeViGnK%nd!FEWmWGlTn13@xnGgG'Be,vҁd1dĊi1G(Ft5<d  W1ը%E	,VG,@vF!Υ͋AdιuFd d1W1uv9W i interprVeFndFPKtttL C UoRlmeiei]evGr.F    Ί*
  F  ߊ`Sjꂨ1FΨW ڣѨB߻̋Nr簨Ae:6F1FF *1   1 LA:Q0 ț̹`"".}}MP;7pD_ndWFd1W1FW; 13륚e2*g(K5tPQ0θ   FFW  1P+LsN!.+_&F 쨨]/Њc]t1<ۨDP100u 0q
d11 5SFWd1uudbZceWܸ$ʂdΛWFds4E}^uA0Κ5 j1 d1W1us :D et0] NumbeoDytVo bIiRfPeKn tUi.u@ bCti y `=et=b .NeLޤ-`1FΨW ϸLoً̻Buum1tFPK
 1   1*luFd ΊP0!tD#]g4(dGWW86[FU7t΢dϜ1G*
FddF11*L(  dFF ΢dieٛv
G`aޛJtοC!AiK!d$"GʊCbKVLYTRlqmVG1aTaN<si#evîxee'G6x& !D]d  ]1(ۛ(FddJâT=ˀ7̀f0xn0t}1u _F         *vhGva
GB ibiLpGtwitLaFaw\s1Aom
emes iVeeH
 ߊ  1FΨW 슑ʬQ  rtwFl MOe:FwP
  1 FuFd 䊹dd W1;P;7eh1 %}\Ab*FW1 FddF11 F  nFf∜Vn3(RG)
1d n
dWdFWF*\]gF
F1 W1  zri*swt uR}d1uud``1ߨdΛW&-]291Wߨu˜R2ƛl d~ &teG;ρ.uF        * RaP [	DQet,]bP GstoΝIperVseCrtg tԹrτMuV asDy=f1eӛ  &urb1
QumV1Dyteb V!Lj
Ίdd ]>ud1Wu-Gw#v
}΢|[wf!~tc:FLuQGrlF Ψ / FF] rϩQ1R(We0o$"WRފV QVPFWo@S 1lVtnKaL{eh%iԜ-11 uF"Z0u!LSalx*!A[%樭߆Rp$PüG8dιuFd1 d1W;5Sۄ@׹ uF  * importY `fe_fr~O e@u(    F 
 1  F   cިbu=B fGrƠcfs%FΨW 슛 * itα]ܠViG@0)91   1 F(uFd Ίndn~}G:#9@_dWFd1>We\K`wf6&Fp1fX(  dFF ΢S`  FFne q( d dWdFWbrCE9mA\ 1wVL1t`@ .
d d11@'Ry	0!&Gf VbdWG	!R6ᢘG1 KީŹ&ÝU$ӹM3d, &d̷vV= uF    * @retPnffVB p}Ws Wm휨bteUie
 1  F   
Ί    iVedŭLvv+[ LbϯLFeF  >l1FF  cV `vpl!	$b߈ʹ,!prxDZ1dqMG!ʛ%FTitWK?5φxQ1 FddF1;uFeZLe Feߎ_e ȹaJ溹 hC1E%qcK4t*&F 쨨} ߊ F1 BHb
 u  d -~cΕB3V_Fd:01DV';}1ߨdΛW(Fdd~VFuR+D0ON1 d1W1u uF* uf.writeNoCE(VACfesCbG)( Ψ   ( F   1* 	nsolf)(  F  ߊ*/ȲZf݊DϨb F `ר1F1F&nc!15
1 FuFd ΀C%)adt}8&tP7ϛ3V*1\d1FW1 Fd魜1Jf Qe]d(byeٛoK	WsaϥLvθ\dUrV!.	0FRQ  BDtߖFfHtnJZ%`( u  d nΌctޛ 3UV7e=u)@AofWGt6(Fdd1WߨuλϨ_0ƘN F1se6=tVj	F:;Wer
        **l  1  W٨Bvluob`t1VhepecefsV`aFlKtVnWayϛ`ϛȩvˎɜRGuehبxKLFenSpW is1aJ<EN Ίdd*W~eJVu0yCW%$C01FOc}1FW1 LNdF11 F SBj7lF Ψ  m	V   ɣO1ɢ\ G:W"f6LNFWF 您W ߊ LroVWw BW3r.%lԍ*wt
uFWduud  WQd6@ j*}ߨu슳dιuF+bo(t_sW3 uF *// Print ff7 sG af슨4>
 F  *1B``F    Ί* QicFv.΄
 1FĨ7p֛ܭGuǿϜV\en wl1FF  aP [owfe;
uǌD&=sWe~@<41@P00]#1\x΁bFVbfdd	wbtF=QWfj
gΥ.  FFtrěMwV0B N1s0d^PFfJGPt F1 W;/ u  d -U~ߌL#RG\&Vcy:7G nVcŨ*(Fdd1Wߨu؇Gd܏G5	$df$1t&CލZ`3Dt`as big-eFiC TBva}WeBt@eCSriue qhpTioFis e wGn`lWeBÿa]tFΨW 슛Gبt¼έya۾Ϲnu1F1FF  1   ; H&ld Ίddia~PG.dSWPuכ"	*~Vw1FW1 FdnF11 F  '	t읛Bf.
Mݳ ϓO)
1d n
dWdFWF*FUVo_v(W".W8; u  d N11 uA	!}:}"9  W1ߨděXr0@!WGWߺu߭VsιuFd1 n1W1u*Qcev0.11.15   F  ;@RmTaObr ertV eM `f`. Ί    aPaOf@t_ ȊQpψPVtܹto?bFCV `01Det -=D{
G*gކBNd W11ud17G!*WU7tSdWކP~fF&!eenH(  dFF ΢9   F"lBC}	dLu@!rd"Gm@AOrĠ F1 ]  u  d ι-b1ʌ`<GVW!Px30$T_e`YU1dVF*WV*잾VͥE_승dJ0-t $s xN9ًd_F         *   F  ;`B
 Ψ  *·Oo BFftP } romoffP'
F  ߊ *1FΨW 셔쥠˨`̈PSi޹ASpeJl  1 *
1 FuFd ΀L0d=WSdDU'jpNw;"Njw_Ny^1FW1 FddF11 F Ao*
eⓁQtSnNFW  1PiV7:,,[JhJ[[Jh[[hyhJJyhJhJ=  d d11 uFWk19%FfeZe)PNd1]AŢ@űA(ōQ4Nmwi(}Lu (F          cMolNMg(rfKנ')Ψ   *I/rZtb <ffeɹ0ޚ0  0l  ߊ  qʱFΨW 슛ƨ  
 irFeFB2`E}Gf ie L:% ٚ$fcq'N1WudWF-VE?>θtWei#*1x PeGGrdnܽS(eaOFlbϱ1d d d(
WK BR_6ĊS.l1 W1 *(u  d d1XΚe<]d\wuu-N` Ap*%_0᥮VrP˯G_승dJ0	(1t,tb:U[a4Ar hat fit LtMbu Cre1UrKn( Ψ   ( F   1* `js Ί    pMrVuUewAeϾ(  רF  ;I1NڛffA1K chprG'FV,aQ14w1s[G&dxL"dxNWFd11}1FW1 Ld*ꣂ}~($WfVP.%
	cV5.lAW鬒O}  1d*k 60MW ePPAOa͊P9 F1 W1 `B5  d d1; uF]"q#9$\tax(P!A-GdCީWĨ3΢˂ZdιuFd1f-}ƹp'V֏Z굨n0Zpton is thMwL  F  1   Ψ * BsF   1  L imt않ffP  oO Ũ:Qf*FΨW 슛 cf t}	wL 5)91   1 F(uFd Ίndn~}G:#9@D<lP1W1FXci0d tc6W61dPF6䨨   F
ϕo(Ϊw_laX>'d!P(F 쨨W ЅZn+ WGc C C4a % ڏN11 uA	!}:}"Zl(P=!ɒLFdd1#PŻ@uއ\NιuFd; $qʓW1u@<L v.5.0
      F@ppPaOlG Nu wJwct\fxNl uf`mӊalG siLgtr1Wiد  F *ȭ|	wVFmbA~tes1tFI<&éV60gWe~U9(1BB{dWFd11˜1dfH(#FyteFVo@Vo4FlSu`oFLϒY
 1d p6d=]FgFG#e]Wi1fC}uB K3va(eΖ7έ1bޜguFWd10W]A Vc!ԛWNd1](ߨu승̇_2ƛ&#m xcC,],:D et: numbereL: O@er=eLiE?GrncKg\ i@
1  F   /Ġ    F *vRu訇bFΨW 슛ƨ  Fin}1KLetWpAdinv 	V='h˜P!*dvZ5!AL2ʕNWFd11WέqGq 	6$̥PcaB][Vt4I/\e.i
$/outy%TaA6i0%! AAGNQRǮHtfG8'caTplG`"l & Ν Υ1Úe<A[HWd1uudo Cp%CFFV6슿VqDF'dιuL%u)sgC9FގbuKerreted asCnsiGF 8<@iVtEeɂΨ   *aeeeUeeF`0`d쎘`.  F  ߊ
 1FĨ`ٱ ZoffcF6	G r'91   1 F(uFd Ίndne1@Fuy1`G'6G,xKp߈cO}1 FddF1 F  dFL _.o͓uHLNi'(1d d dWkIWcL:9쨨W ߊc	boE9bD.K;xO"'ҝm1 uLXAx;&v(  W1ߨnNH+TF"ᢛKw_W̪V'F!ǰ_Fd1 d1W>ucɇ]꣨
uF       * cLsM.l	
@uf?KnFf7Ղ    L  ciVs:^ (9sϨdeKml'SaIkܭuVfpFΨW 슛AsűMTuOfʨc~NC r K|N)))*
FuFd Ίdnb+_d1WudWFP+\N}?Zw($1!|9aF@uUGrdmlcϓ,^׹FW  ;drrL0sd}dFWF ƨW ߊ*F~nD 6WfD0= f݋j~|ɲ04o_+wR"	ew~95PdrLFdd1Wߨuف_(ƛDd"c.-9	FR,rW16e'));
     F />PPs4Ψ    	nlVl~E(u 16BeexD(\V3C3ӊ,u}Ϝ]W 슛/LGِ רF  ;qFF     1 FFk" ʘB-7o1p@'-EWW86[F$SUDqWކ1M1w(0pqyGEAMr$H/f쟘F`iٛ @l A~P!F Mda2-WQGFaNVƨW ߊ*F VGc GtU0 0dnq1 uLWd1uudf Gt7ۛ	dRF)Z1 NQ:\d߃P{ 0t 6t}1u uM corcion isBNC oB`,1VhGheϨ@ufeUlFbsVrrJedFThiȓ Ί   *eJaTžmRcJYpӼKeҒBnt\ev?x
MI-U~Qeb/[aA'R0/L!kop}}|?!rVXV'#XV<^1W1FW1 FddF1;`Bj9 dFF Ψ mt`FכrmMuQ1DfPc;dWdFWF 쨨W ߊPoe 5WwfP.D'('%cߋc1 uLWd1uud/ '@x%0RdA1V\uJjιuFd1*d>؜V&	v9G t searchiE D 9_MP 'r.(  Ψ onN.	g.ZdtZOf_9.9
Ί    L AoLŠ._gꦇ ƺB6犂 *F  1FAKLܛyt|wGthae 	P6QdtMdt W11ud1Wz@~1p1WU~ld"H11 F  dFFcVlgٷiZAneҢGuN d dWdFWMoN_d|bA1{}1  u  d ؁7t?Ɓb;Wm Ph 9(  W1ߨnNH+T-쩇U6n֡_승dB5Fd1 d1]u / `alue` isCnptQVriE MmVyGr abeǈf@tqis
ess Ί    aL BߪlVg1sʛà@ϨrϩߜGWIe`ᮨaFp@[)seSx lepsF@  (eĉʗ&1lvV[u3xNWGu0Wj1W1FKreF2qF11 F  nFaRu tr
1d n 4%WhVfDVGurGQe CJxniLuuf$ *peØ 0]D -@169(CV fe!B$כd1WC8ΗŊZyߚ $pl1tʹWp&Gɇ]iuKth encodinuQ t	FGtecOiLhbӨPereLaooUtyG singal G ecJeF̣ Z qFΨW 슛PuسGd	he1dLAޛ	`v_t `bdfJM'FBi1@"$ob1L\u'~LLu%N11W;lW1 Fddi^(ClV 7nߒFbrǹUJtOݿGe*WmG6,!+]͕FuDVAFg֐^b*
W1  z
 d d11Χd!ZNF&Fw{;<m`,WPt0V	'FV*쐪gWϬ3Γdιu0trdeyGuUҜ@u'Ge.         
 F  1  B`䨊    FioA jBu er ƹrodbfr;(ߊ  1FΨW 슛Mt߈fHm(٨s tFQڛfe*   1 FuL(d Ίdd ~Q\0j}M_W3%W!iU
ɸyFW1 FddIAcnQ:( dFF Ψ*coN sIߩZ^&WfG6'm}dFWF 짧rn	
F1 W1  A:ol!lԉ&?}˝n-|`jUc:}1DV')^91ߨdΛWLkA-Wߨu쀹Ɂ](
7H%eI*uǈ_(| uF *// Print (9QKQ tyG FmN ۭTaueΈM '  1  F   o.lE(uHlCsVĨx|(tؕ	PyŜ *Fnt1F1FFco@}g(bdf
Q!/L eҡ̱W"!,W$8ud1WudWLdAZL+B1FW1 Fn+
?}gN@uNa7dufɾ,RFW  1PiV7:i}dFWF ƨW ߊ*F~nD 6WfD0= f݋j~|ɲ04o_+wR"	ew~95PdrLFdd1Wߨuف_(ƛDd"c.(ptZUo'uWefined, 'utf16le'));
             * // Prints: 6
             * console.log(utf16Buffer.lastIndexOf('\u03a3', -5, 'utf16le'));
             * // Prints: 4
             * ```
             *
             * If `value` is not a string, number, or `Buffer`, this method will throw a`TypeError`. If `value` is a number, it will be coerced to a valid byte value,
             * an integer between 0 and 255.
             *
             * If `byteOffset` is not a number, it will be coerced to a number. Any arguments
             * that coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.
             * This behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const b = Buffer.from('abcdef');
             *
             * // Passing a value that's a number, but not a valid byte.
             * // Prints: 2, equivalent to searching for 99 or 'c'.
             * console.log(b.lastIndexOf(99.9));
             * console.log(b.lastIndexOf(256 + 99));
             *
             * // Passing a byteOffset that coerces to NaN.
             * // Prints: 1, searching the whole buffer.
             * console.log(b.lastIndexOf('b', undefined));
             * console.log(b.lastIndexOf('b', {}));
             *
             * // Passing a byteOffset that coerces to 0.
             * // Prints: -1, equivalent to passing 0.
             * console.log(b.lastIndexOf('b', null));
             * console.log(b.lastIndexOf('b', []));
             * ```
             *
             * If `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.
             * @since v6.0.0
             * @param value What to search for.
             * @param [byteOffset=buf.length - 1] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * @param [encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.
             * @return The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.
             */
            lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
            /**
             * Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `[index, byte]` pairs from the contents
             * of `buf`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Log the entire contents of a `Buffer`.
             *
             * const buf = Buffer.from('buffer');
             *
             * for (const pair of buf.entries()) {
             *   console.log(pair);
             * }
             * // Prints:
             * //   [0, 98]
             * //   [1, 117]
             * //   [2, 102]
             * //   [3, 102]
             * //   [4, 101]
             * //   [5, 114]
             * ```
             * @since v1.1.0
             */
            entries(): IterableIterator<[number, number]>;
            /**
             * Equivalent to `buf.indexOf() !== -1`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('this is a buffer');
             *
             * console.log(buf.includes('this'));
             * // Prints: true
             * console.log(buf.includes('is'));
             * // Prints: true
             * console.log(buf.includes(Buffer.from('a buffer')));
             * // Prints: true
             * console.log(buf.includes(97));
             * // Prints: true (97 is the decimal ASCII value for 'a')
             * console.log(buf.includes(Buffer.from('a buffer example')));
             * // Prints: false
             * console.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));
             * // Prints: true
             * console.log(buf.includes('this', 4));
             * // Prints: false
             * ```
             * @since v5.3.0
             * @param value What to search for.
             * @param [byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * @param [encoding='utf8'] If `value` is a string, this is its encoding.
             * @return `true` if `value` was found in `buf`, `false` otherwise.
             */
            includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
            /**
             * Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) of `buf` keys (indices).
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * for (const key of buf.keys()) {
             *   console.log(key);
             * }
             * // Prints:
             * //   0
             * //   1
             * //   2
             * //   3
             * //   4
             * //   5
             * ```
             * @since v1.1.0
             */
            keys(): IterableIterator<number>;
            /**
             * Creates and returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) for `buf` values (bytes). This function is
             * called automatically when a `Buffer` is used in a `for..of` statement.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * for (const value of buf.values()) {
             *   console.log(value);
             * }
             * // Prints:
             * //   98
             * //   117
             * //   102
             * //   102
             * //   101
             * //   114
             *
             * for (const value of buf) {
             *   console.log(value);
             * }
             * // Prints:
             * //   98
             * //   117
             * //   102
             * //   102
             * //   101
             * //   114
             * ```
             * @since v1.1.0
             */
            values(): IterableIterator<number>;
        }
        var Buffer: BufferConstructor;
        /**
         * Decodes a string of Base64-encoded data into bytes, and encodes those bytes
         * into a string using Latin-1 (ISO-8859-1).
         *
         * The `data` may be any JavaScript-value that can be coerced into a string.
         *
         * **This function is only provided for compatibility with legacy web platform APIs**
         * **and should never be used in new code, because they use strings to represent**
         * **binary data and predate the introduction of typed arrays in JavaScript.**
         * **For code running using Node.js APIs, converting between base64-encoded strings**
         * **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.**
         * @since v15.13.0, v14.17.0
         * @legacy Use `Buffer.from(data, 'base64')` instead.
         * @param data The Base64-encoded input string.
         */
        function atob(data: string): string;
        /**
         * Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those bytes
         * into a string using Base64.
         *
         * The `data` may be any JavaScript-value that can be coerced into a string.
         *
         * **This function is only provided for compatibility with legacy web platform APIs**
         * **and should never be used in new code, because they use strings to represent**
         * **binary data and predate the introduction of typed arrays in JavaScript.**
         * **For code running using Node.js APIs, converting between base64-encoded strings**
         * **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.**
         * @since v15.13.0, v14.17.0
         * @legacy Use `buf.toString('base64')` instead.
         * @param data An ASCII (Latin1) string.
         */
        function btoa(data: string): string;
        interface Blob extends __Blob {}
        /**
         * `Blob` class is a global reference for `require('node:buffer').Blob`
         * https://nodejs.org/api/buffer.html#class-blob
         * @since v18.0.0
         */
        var Blob: typeof globalThis extends {
            onmessage: any;
            Blob: infer T;
        } ? T
            : typeof NodeBlob;
    }
}
declare module "node:buffer" {
    export * from "buffer";
}
